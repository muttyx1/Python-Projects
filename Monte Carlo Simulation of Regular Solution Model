import matplotlib.pyplot as plt
import numpy as np
import math
#V = L^d, where V is volume of the lattice, L is the length of the Lattice, and d is the dimensions
#L = 10, d = 2
# x subscript k = {0, 1, 0, .....}
# E subscript k = Sum[psubisuperk * psubjsuperk * epsilonAA]
# i.e. the energy of the lattice = sum of all the interactions
# epsilonAA = epsilonBB = 0, epsilonAB = epsilonBA = 1
# 40 steps of T
# 10^6 runs per step
def boundary_function(array,i,j,E):
    something = [1,2,3,4,5,6,7,8]
    E = 0
    if i == 0 and j == 0: # NW Corner
        if array[i,j] != array[i,9]:
            E = E + 1
        if array[i,j] != array[i,j+1]:
            E = E + 1
        if array[i,j] != array[i+1,j]:
            E = E + 1
        if array[i,j] != array[9,j]:
            E = E + 1
    elif i == 0 and j == 9: # NE Corner
        if array[i,j] != array[i,j-1]:
            E = E + 1
        if array[i,j] != array[i,0]:
            E = E + 1
        if array[i,j] != array[i+1,j]:
            E = E + 1
        if array[i,j] != array[9,j]:
            E = E + 1
    elif i == 9 and j == 0: # SW Corner
        if array[i,j] != array[i,9]:
            E = E + 1
        if array[i,j] != array[i,j+1]:
            E = E + 1
        if array[i,j] != array[0,j]:
            E = E + 1
        if array[i,j] != array[i-1,j]:
            E = E + 1
    elif i == 9 and j == 9: # SE Corner
        if array[i,j] != array[i,j-1]:
            E = E + 1
        if array[i,j] != array[i,0]:
            E = E + 1
        if array[i,j] != array[0,j]:
            E = E + 1
        if array[i,j] != array[i-1,j]:
            E = E + 1
    elif i == 0 and j in something: # North Side
        if array[i,j] != array[i,j-1]:
            E = E + 1
        if array[i,j] != array[i,j+1]:
            E = E + 1
        if array[i,j] != array[i+1,j]:
            E = E + 1
        if array[i,j] != array[9,j]:
            E = E + 1
    elif i == 9 and j in something: # South Side
        if array[i,j] != array[i,j-1]:
            E = E + 1
        if array[i,j] != array[i,j+1]:
            E = E + 1
        if array[i,j] != array[0,j]:
            E = E + 1
        if array[i,j] != array[i-1,j]:
            E = E + 1
    elif i in something and j == 0: # West Side
        if array[i,j] != array[i,9]:
            E = E + 1
        if array[i,j] != array[i,j+1]:
            E = E + 1
        if array[i,j] != array[i+1,j]:
            E = E + 1
        if array[i,j] != array[i-1,j]:
            E = E + 1
    elif i in something and j == 9: # East Side
        if array[i,j] != array[i,j-1]:
            E = E + 1
        if array[i,j] != array[i,0]:
            E = E + 1
        if array[i,j] != array[i+1,j]:
            E = E + 1
        if array[i,j] != array[i-1,j]:
            E = E + 1
    else: # Everywhere else
        if array[i,j] != array[i,j-1]:
            E = E + 1
        if array[i,j] != array[i,j+1]:
            E = E + 1
        if array[i,j] != array[i+1,j]:
            E = E + 1
        if array[i,j] != array[i-1,j]:
            E = E + 1
    return E
def swapPosition(array,i0,j0,i1,j1):
    x2 = np.copy(array)
    #x2[i0,j0],array[i1,j1] = x2[i1,j1],array[i0,j0]
    if x2[i0, j0] == x2[i1, j1]:
        #print(x1local)
        return x2
    elif x2[i0, j0] == 1 and x2[i1, j1] == 0:
        #print(x2local)
        x2[i0, j0] = 0
        x2[i1, j1] = 1
        #print(x2local)
        return x2
    elif x2[i0, j0] == 0 and x2[i1, j1] == 1:
        #print(x2local)
        x2[i0, j0] = 1
        x2[i1, j1] = 0
        #print(x2local)
        return x2
    #return x2
def energy_sum(array):
    E = 0
    for i in range(10):
        for j in range(10):
            E = E + boundary_function(array,i,j,0)
    return E
def whole_code():
    x1 = np.random.randint(2, size=(10,10))
    T = 1
    x = []
    y = []
    for n in range(100000):
        i0 = np.random.choice(10)
        j0 = np.random.choice(10)
        i1 = np.random.choice(10)
        j1 = np.random.choice(10)
        Eold = energy_sum(x1)
        x2 = swapPosition(x1,i0,j0,i1,j1)
        Enew = energy_sum(x2)
        deltaE = Enew - Eold
        r = np.random.uniform(low=0.0, high=1.0, size=None)
        rcompare = math.exp((-deltaE)/(1*T))
        if deltaE < 0 or r < rcompare:
            #print(math.exp((-deltaE)/(1*T)))
            x1 = np.copy(x2)
            y.insert(n,Enew)
            x2 = np.empty([10,10])
            x.append(n)
        else:
            x.append(n)
            y.insert(n,Eold)
    print(x1)
    return x, y
x, y = whole_code()
plt.plot(x,y)
plt.show()
